# ai_handler.py

import asyncio
from google import genai
from google.genai import types
from google.api_core import exceptions as google_exceptions

# Define a custom exception for our application.
class AIGenerationError(Exception):
    """Custom exception for failures during AI content generation."""
    pass

class AIHandler:
    """A general-purpose handler for interacting with the Gemini 2.5 API."""

    def __init__(self, api_key: str, model: str, max_output_tokens: int):
        if not api_key:
            raise ValueError("API key for the generative AI service is not set.")
        self.model = model
        self.max_output_tokens = max_output_tokens

    def _blocking_generate(self, prompt: str) -> str:
        """A private, synchronous method that contains the actual blocking API call."""
        client = genai.Client()
        request_config = types.GenerateContentConfig(
            max_output_tokens=self.max_output_tokens,
            thinking_config=types.ThinkingConfig(thinking_budget=0),
        )

        try:
            # This is the critical point where we interact with the external service.
            response = client.models.generate_content(
                model=self.model,
                contents=[prompt],
                config=request_config
            )
            return response.text or ""
        except google_exceptions.GoogleAPICallError as e:
            # Catch the specific library error and raise our own, cleaner exception.
            # This makes the rest of our application independent of the google-genai library's errors.
            raise AIGenerationError(f"The AI API call failed: {e}") from e
        except Exception as e:
            # Catch any other unexpected errors during the API call.
            raise AIGenerationError(f"An unexpected error occurred during AI generation: {e}") from e


    async def generate(self, prompt: str) -> str:
        """Generates content asynchronously by running the synchronous API call in a separate thread."""
        return await asyncio.to_thread(self._blocking_generate, prompt)
# app.py

import asyncio
from typing import Optional, Coroutine, TypeVar, Any

from config import get_config
from ai_handler import AIHandler, AIGenerationError
from lore_types import Agents, Turn, BaseInteraction, Reality
from entities import Agent, Environment
from prompts import PROMPT_TEMPLATES
from chronicle import Chronicle

T = TypeVar('T', bound=BaseInteraction)

class LoreGamesApp:
    """The central orchestrator for the Lore Games simulation."""

    def __init__(self):
        self.config = get_config()
        self.ai_handler = AIHandler(api_key=self.config["ai"]["api_key"], model=self.config["ai"]["model"], max_output_tokens=self.config["ai"]["max_output_tokens"])
        self.prompts = PROMPT_TEMPLATES
        self.chronicle = Chronicle(base_path="state_dump")
        self.agents: Agents = {}
        self.environment: Optional[Environment] = None
        self.current_turn: Turn = 0

    async def _execute_and_log(self, interaction_coro: Coroutine[Any, Any, T]) -> T:
        """Awaits an interaction coroutine, logs it, and returns the result."""
        try:
            result = await interaction_coro
            self.chronicle.log(result)
            return result
        except AIGenerationError as e:
            print(f"FATAL: An AI generation error occurred: {e}")
            raise

    def setup(self):
        # ... (setup method remains the same) ...
        print("--- Initializing Simulation ---")
        for name, agent_config in self.config["initial_agents"].items():
            new_agent = Agent(id=name, personality=agent_config["personality"], ai_handler=self.ai_handler, prompts=self.prompts)
            self.agents[name] = new_agent
            print(f"Created agent: {name}")
        env_config = self.config["environment"]
        self.environment = Environment(id=env_config["id"], initial_reality=env_config["initial_reality"], ai_handler=self.ai_handler, prompts=self.prompts)
        print(f"Created environment: {self.environment.id}")
        print("-----------------------------")

    async def _prime_agents(self):
        assert self.environment is not None
        print("\n--- Priming Agents (Turn 0) ---")
        for agent in self.agents.values():
            initial_perspective = await self._execute_and_log(self.environment.initial_reflection(agent, self.current_turn))
            agent.prime(initial_perspective)
            print(f"Primed {agent.id}.")
        print("---------------------------------")

    async def _execute_turn(self):
        assert self.environment is not None
        self.current_turn += 1
        print(f"\n--- Starting Turn {self.current_turn} ---")
        print(f"Reality: {self.environment.reality.get(self.current_turn - 1)}")
        for agent in self.agents.values():
            perspective = await self._execute_and_log(self.environment.reflect(agent, self.current_turn))
            agent.add_memory(self.current_turn, perspective)
            print(f"{agent.id} perceives: \"{perspective.content[:80].strip()}...\"")
            intention = await self._execute_and_log(agent.intent(self.current_turn))
            self.environment.add_intention(agent.id, intention)
            print(f"{agent.id} intends: \"{intention.content[:80].strip()}...\"")
        divination = await self._execute_and_log(self.environment.divine(self.current_turn))
        self.environment.reality[self.current_turn] = divination.content
        final_reality = Reality(owner=self.environment.id, turn_origin=self.current_turn, content=divination.content)
        self.chronicle.log(final_reality)
        print(f"\nNew Reality: {divination.content}")
        print("--- End of Turn ---")

    async def run(self):
        """The main application loop."""
        self.setup()
        await self._prime_agents()
        while True:
            user_input = input("\nPress Enter to advance to the next turn (or type 'quit' to exit)...")
            if user_input.lower() == 'quit':
                break
            await self._execute_turn()
# chronicle.py

import os
from functools import singledispatchmethod
from dataclasses import fields, is_dataclass
from lore_types import (
    BaseAIInteraction, InitialPerspective, Perspective, Intention, Divination, Reality
)

class Chronicle:
    """Handles the logging of simulation state to disk."""

    def __init__(self, base_path: str = "state_dump"):
        self.base_path = base_path
        os.makedirs(self.base_path, exist_ok=True)

    def _write_file(self, turn: int, filename: str, content: str):
        """Helper to write content to a turn-specific directory."""
        turn_dir = os.path.join(self.base_path, f"turn_{turn:03d}")
        os.makedirs(turn_dir, exist_ok=True)
        with open(os.path.join(turn_dir, filename), 'w', encoding='utf-8') as f:
            f.write(content)

    @singledispatchmethod
    def log(self, interaction: object, **kwargs):
        """Generic logger for unknown types."""
        print(f"Warning: No specific chronicle logger for type {type(interaction)}")

    @log.register
    def _(self, interaction: InitialPerspective):
        filename = f"{interaction.owner}_initial_perspective.md"
        self._log_standard_interaction(interaction, filename)

    @log.register
    def _(self, interaction: Perspective):
        filename = f"{interaction.owner}_perspective.md"
        self._log_standard_interaction(interaction, filename)

    @log.register
    def _(self, interaction: Intention):
        filename = f"{interaction.owner}_intention.md"
        self._log_standard_interaction(interaction, filename)

    @log.register
    def _(self, interaction: Divination):
        filename = f"{interaction.owner}_divination.md"
        self._log_standard_interaction(interaction, filename)

    @log.register
    def _(self, interaction: Reality):
        filename = "reality.md"
        header = f"### Turn: {interaction.turn_origin} | Final Reality\n\n"
        self._write_file(interaction.turn_origin, filename, header + interaction.content)

    def _log_standard_interaction(self, interaction: BaseAIInteraction, filename: str):
        """A standardized formatter for most interaction types."""
        # Header
        header = f"### Turn: {interaction.turn_origin} | Owner: {interaction.owner}\n"

        # Prioritize prompt and content
        prompt_section = f"#### Prompt\n```\n{interaction.prompt}\n```\n\n" if interaction.prompt else ""
        content_section = f"#### Content\n{interaction.content}\n\n"

        # Metadata for all other fields
        metadata_section = "#### Metadata\n```\n"
        for f in fields(interaction):
            if f.name not in ['prompt', 'content', 'owner', 'turn_origin', 'template_key']:
                value = getattr(interaction, f.name)
                metadata_section += f"{f.name}: {value}\n"
        metadata_section += "```\n"

        full_content = (
            header + prompt_section + content_section + metadata_section
        )
        self._write_file(interaction.turn_origin, filename, full_content)
# config.py

"""
Central configuration for the Lore Games simulation.
"""
import os
from typing import Dict, Any, List

_AGENTS_LIST: List[Dict[str, str]] = [
    {
        "name": "Charlie",
        "personality": "A goblin which survived being thrown into a ceremonial bonfire; Charlie has a new appreciation for life.",
    },
    {
        "name": "Delta",
        "personality": "A mechanoid which speaks through a lo-fi speaker, Delta is fascinated by biology.",
    },
]

INITIAL_AGENTS: Dict[str, Dict[str, str]] = {
    agent['name']: agent for agent in _AGENTS_LIST
}

def get_config() -> Dict[str, Any]:
    """Returns the main configuration dictionary for the simulation."""

    config: Dict[str, Any] = {
        "simulation": {
            "write_to_file": True,
            "print_to_cmd": True,
            "flow": "simple",
        },
        "ai": {
            "max_output_tokens": 556,
            "api_key": os.environ.get("GEMINI_API_KEY"),
            "model": "gemini-2.5-flash", # 2.5 is absolutely intentional, don't change it.
        },
        "initial_agents": INITIAL_AGENTS,
        "environment": {
            "id": "environment",
            "initial_reality": "A sprawling shantytown built on the interconnected rooftops of a sleeping city.",
        },
    }

    return config
# entities.py

from typing import Dict, Any
import textwrap
from dataclasses import replace

from ai_handler import AIHandler
from lore_types import (
    EntityID, Personality, Memory, Turn, Intention, InitialPerspective,
    Perspective, Divination, PrimerContent, AgentsIntent
)

def _format_prompt(prompts: Dict, template_key: str, data: Any) -> str:
    """A helper utility to format a prompt from the templates dictionary."""
    key1, key2 = template_key.split('.')
    template = prompts[key1][key2]
    return textwrap.dedent(template).strip().format(**data.__dict__)

class Agent:
    """Represents an autonomous entity that can perceive, reason, and act."""
    def __init__(self, id: EntityID, personality: Personality, ai_handler: AIHandler, prompts: Dict):
        self.id: EntityID = id
        self.personality: Personality = personality
        self.primer: PrimerContent = ""
        self.memory: Memory = {}
        self.ai_handler = ai_handler
        self.prompts = prompts

    def prime(self, initial_perspective: InitialPerspective) -> None:
        """Generates and stores the agent's foundational primer."""
        self.primer = textwrap.dedent(f"""
            <ROLE>
                You are {self.id}, you are described like this: {self.personality}.

                You recall your earlier perspective:

                {initial_perspective.content}.
            <ROLE END>
        """).strip()

    async def intent(self, current_turn: Turn) -> Intention:
        """Forms and returns the agent's full intention interaction."""
        formatted_memory = "\n".join(
            f"Turn {t}: {p.content}" for t, p in self.memory.items()
        )
        request = Intention(
            owner=self.id,
            turn_origin=current_turn,
            primer=self.primer,
            formatted_memory=formatted_memory,
            content=""
        )
        prompt = _format_prompt(self.prompts, request.template_key, request)
        response = await self.ai_handler.generate(prompt)
        return replace(request, content=response, prompt=prompt)

    def add_memory(self, turn: Turn, perspective: Perspective):
        """Adds a new perspective object to the agent's memory."""
        self.memory[turn] = perspective

class Environment:
    """Represents the shared reality and orchestrates simulation turns."""
    def __init__(self, id: EntityID, initial_reality: str, ai_handler: AIHandler, prompts: Dict):
        self.id: EntityID = id
        self.primer: PrimerContent = textwrap.dedent(prompts["env"]["primer"]).strip()
        self.reality: dict[Turn, str] = {0: initial_reality}
        self.agents_intent: AgentsIntent = {}
        self.ai_handler = ai_handler
        self.prompts = prompts

    async def initial_reflection(self, agent: "Agent", turn_current: Turn) -> InitialPerspective:
        """Generates an agent's first look at the world."""
        request = InitialPerspective(
            owner=agent.id,
            turn_origin=turn_current,
            primer=self.primer,
            personality=agent.personality,
            content=""
        )
        prompt = _format_prompt(self.prompts, request.template_key, request)
        response = await self.ai_handler.generate(prompt)
        return replace(request, content=response, prompt=prompt)

    async def reflect(self, agent: "Agent", turn: Turn) -> Perspective:
        """Generates an agent's perspective on the current reality."""
        current_reality = self.reality.get(turn - 1, "A formless void.")
        request = Perspective(
            owner=agent.id,
            turn_origin=turn,
            primer=self.primer,
            personality=agent.personality,
            reality_formatted=current_reality,
            content=""
        )
        prompt = _format_prompt(self.prompts, request.template_key, request)
        response = await self.ai_handler.generate(prompt)
        return replace(request, content=response, prompt=prompt)

    def add_intention(self, agent_id: EntityID, intention: Intention):
        """Records an agent's intention object for a given turn."""
        self.agents_intent[agent_id] = intention

    async def divine(self, current_turn: Turn) -> Divination:
        """Interprets intentions and produces the next state of reality."""
        reality_state = self.reality.get(current_turn - 1, "A formless void.")
        agents_intent_formatted = "\n".join(
            f"Agent {id}'s intention: {intent.content}" for id, intent in self.agents_intent.items()
        )
        request = Divination(
            owner=self.id,
            turn_origin=current_turn,
            primer=self.primer,
            reality_state=reality_state,
            agents_intent_formatted=agents_intent_formatted,
            content=""
        )
        prompt = _format_prompt(self.prompts, request.template_key, request)
        response = await self.ai_handler.generate(prompt)
        return replace(request, content=response, prompt=prompt)
# lore_types.py

from dataclasses import dataclass, field
from typing import TypeAlias, Dict, TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from entities import Agent

# --- Core Type Aliases ---
EntityID: TypeAlias = str
Turn: TypeAlias = int

# --- Advanced Type Aliases ---
PrimerContent: TypeAlias = str
Personality: TypeAlias = str
Memory: TypeAlias = Dict[Turn, "Perspective"]
AgentsIntent: TypeAlias = Dict[EntityID, "Intention"]
Agents: TypeAlias = Dict[EntityID, "Agent"]
PromptTemplate = Dict[str, str | Dict[str, str]]

# --- Interaction Dataclasses ---

@dataclass(frozen=True, kw_only=True)
class BaseInteraction:
    owner: EntityID
    turn_origin: Turn

@dataclass(frozen=True, kw_only=True)
class Reality(BaseInteraction):
    content: str

@dataclass(frozen=True, kw_only=True)
class BaseAIInteraction(BaseInteraction):
    content: str
    prompt: Optional[str] = None

@dataclass(frozen=True, kw_only=True)
class Intention(BaseAIInteraction):
    primer: PrimerContent
    formatted_memory: str
    template_key: str = field(default="agent.intent", init=False, repr=False)

@dataclass(frozen=True, kw_only=True)
class InitialPerspective(BaseAIInteraction):
    primer: PrimerContent
    personality: Personality
    template_key: str = field(default="env.prep_agent", init=False, repr=False)

@dataclass(frozen=True, kw_only=True)
class Perspective(BaseAIInteraction):
    primer: PrimerContent
    personality: Personality
    reality_formatted: str
    template_key: str = field(default="env.reflect", init=False, repr=False)

@dataclass(frozen=True, kw_only=True)
class Divination(BaseAIInteraction):
    primer: PrimerContent
    reality_state: str
    agents_intent_formatted: str
    template_key: str = field(default="env.divine", init=False, repr=False)
# main.py

import asyncio
from app import LoreGamesApp

async def main():
    """The main entry point for the application."""
    game_app = LoreGamesApp()
    await game_app.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nSimulation exited.")
# prompts.py

"""
This file contains the prompt templates for the Lore Games simulation.
"""

PROMPT_TEMPLATES = {
    "agent":
    {
        "primer":
        """
            <ROLE>
                You are {owner}, you are described like this: {personality}.

                You recall your earlier perspective:

                {initial_perspective}.
            <ROLE END>
        """,
        "intent":
        """
            {primer}
            <PROMPT>
                You recall everything that has happened so far:
                <MEMORY>
                    {formatted_memory}
                <MEMORY END>
                You mentally process everything that has happened...
                Now you must decide and describe what you do next.
                Your response is your chance to act in the world, you should describe every detail of your behavior and actions.
                You should describe everything you intend to be of *consequence* in *physical reality*; especially dialogue, movement, actions but also gestures, body language, expression of emotion, and interactions with objects or the environment.
                Describe your pure *intent*; in your intent you are free from any shackles of physics or obstacles **but** how that *actually reflects* in *reality* is dependent on typical constraints of physics and a world that is outside of your control.
                What do you intend to do in this very next moment?
            <PROMPT END>
        """
    },
    "env": {
        "primer":
        """
            <ROLE>
                Sophisticated reality simulation engine.
            <ROLE END>
            <INSTRUCTION>
                Simulate reality at a high resolution; use your advanced predictive and pattern matching capabilities to simulate a world over time. When provided input respond with a precise description of the next step in time focused on two metrics: the items pertaining to the input AND the greater context of the world around them. Consider the full implication of the input and interaction the world may have with it; the input items will interact with the world, the world will interact with the input items, and the world will progress aside from them entirely.
                Respond in a form corresponding to the input.
                Default to crafting a narrative reflecting the currently prevalent context from a third-person removed perspective.
                **Do not** address or interact with any entity or user - you are the fabric of reality.
            <INSTRUCTION END>
        """,
        "prep_agent":
        """
            {primer}
            <INSTRUCTION>
                Describe the world relative to the agent, {owner}; as an individual, they are often described like this: {personality}.

                Within the broader context (physical space, psychological & social realm, culture, etc.), invent some concrete details and context around and about {owner}.
            <INSTRUCTION END>
        """,
        "reflect":
        """
            {primer}
            <INSTRUCTION>
                Detail the *current* state of reality as it pertains, in particular, to the agent, {owner}. As an individual, they are often described like this: {personality}.

                Here is your record of everything that has happened so far:
                <REALITY STATE>
                    {reality_formatted}
                <REALITY STATE END>
                Within the broader context of reality, (physical space, psychological & social realm, culture, etc.), what details are pertinent to this agent in particular?
                Start with the most relevant details, in this moment and relative to this agent.
                Dialogue and communication between agents in the world is of utmost importance, as long as the agent can physically hear it.
                Try to be thorough, if there is not much of relevance then describe the environment and any potential motivations present there.
                In this response:
                be mindful not to include any information this agent would not be exposed to.
                use a third-person, removed, pragmatic voice.
            <INSTRUCTION END>
        """,
        "divine":
        """
            {primer}
            <INSTRUCTION>
                Here is your record of everything that has happened so far:
                <REALITY STATE>
                    {reality_state}
                <REALITY STATE END>
                The independent agents of this world intend to act as follows:
                <AGENTS INTENT>
                    {agents_intent_formatted}
                </AGENTS INTENT>
                Decide and detail how the state of reality and agent's intents will have impact: the effects, outcomes, results, and any relevant contextual information.
                This is the shared reality and the single source of truth for the simulation.
            <INSTRUCTION END>
        """
    }
}
